def_job_exit_trap() { wait; }

def_job_term_trap() {
    echo "Sending TERM to ${MYCHLD}..."
    kill -SIGTERM $MYCHLD &>/dev/null

    # Explicitly exits, thus avoiding continuing from where the trap occured.
    # Will not call the EXIT trap if it was there when TERM was received. 
    exit 1
}

init_job() {
    MYCHLD=" " # this maintains a list of child processes PIDs
    trap 'def_job_exit_trap' EXIT
    trap 'def_job_term_trap' SIGTERM SIGINT
}

run_job() {
    $@ &  # $@ is whatever cames as argument
    MYCHLD+=" $!" # add the child pid to the children list
}

NAME='[.a-zA-Z0-9_\-]+'
GLOB='([\*\{\}\?\^\!\.\,a-zA-Z0-9_\-]|\]?|\[?)+'
BTAG='HG[0-9]{4}[a-zA-Z0-9]+'
DELTA="[ \#]+\+ ?$NAME(\/$NAME|\/\*)?( $GLOB)+"
NEWENTRY="(^|\#)$BTAG $NAME($DELTA)* *($|\#)"

job_process_file() {
    init_job
    local REPO=${1:-comp.pre}
    local FILE="${REPO/%comp/comp.}releases"

    echo "---------[$FILE]----------"
    cd $BUILDER_ROOT/var
    cvs co -d CMSDIST.HEAD CMSDIST ||
        { echo "Could not fetch CMSDIST. Skipping it."; exit 1; }

    # Get rid of comment lines and changes newlines to # to avoid regex headaches
    while read -d "#" ENTRY; do
	echo " * Found entry <$ENTRY>"
	run_job job_build $REPO $ENTRY
    done <<< $(grep -v "#" CMSDIST.HEAD/$FILE | tr -s " \n" " #" | egrep -o "$NEWENTRY" | tr "#\n" " #")

    wait;
    cat $LOG_FILE.*.$REPO.chk 2>/dev/null; echo;
    rm -f $LOG_FILE.*.$REPO.chk

    exit 0 # job succeeded
}

# Returns 0 delta processing succeeds; 1 otherwise
process_delta() {
    local CMSDIST=$1; shift;

    set -B # Enables brace expansion (disabled by default when running scripts) 

    # This loop process each delta
    while [ "$1" = "+" ]; do
        # Gets REV and VER specified on delta
	local REV=${2%%\/*}; local VER=${2#*\/}; shift 2
	[ "$VER" = "$REV" ] && VER="*"  # Blank VER means "*"
	[ "$REV" = "HEAD" -a "$VER" = "*" ] &&
	    { echo "Malformed delta - you must specify version when using HEAD"; return 1; }

	# This loop process files affected by the delta
	while [ "$1" != "+" -a -n "$1" ]; do
	    # $1 is the glob pattern to look for files in CMSDIST HEAD
	    # The 'eval echo' below is needed because brace expansion gets
	    # done before variable expansion.
	    for F in $(eval echo $BUILDER_ROOT/var/CMSDIST.HEAD/$1); do
		test -f "$F" || 
                    { echo "Pattern $1 doesnt expand to any existent file"; return 1; }

		local FNAME=${F##*/} # takes the file name without full path
		echo "DEBUG: file is <$F>"

		# Checks out the file if it doesnt yet exist
		[ -f "$CMSDIST/$FNAME" ] ||
		    { cvs co -r $REV -d $CMSDIST CMSDIST/$FNAME || return 1; }

		local FVER=$(head -n1 $CMSDIST/$FNAME| tr -s " " | cut -d" " -f5 2>/dev/null)
		local FREV=$(grep "/$FNAME/" $CMSDIST/CVS/Entries | cut -d/ -f6 | cut -b2-)
                [ -z "$FREV" ] && FREV=$(grep "/$FNAME/" $CMSDIST/CVS/Entries | cut -d/ -f3)

                [ "$REV" = "HEAD" -a "$VER" != "$FVER" ] &&
                   { cvs up -A $CMSDIST/$FNAME || return 1; }
                [ "$REV" != "HEAD" -a "$REV" != "$FREV" ] &&
                   { cvs up -r $REV $CMSDIST/$FNAME || return 1; } # Make sure the revision match
                [ "$REV" != "HEAD" -a "$REV" = "$FREV" -a "$VER" != "*" -a "$VER" != "$FVER" ] &&
                   { cvs up -r $REV $CMSDIST/$FNAME || return 1; } # Refetch REV to try to match VER

		FVER=$(head -n1 $CMSDIST/$FNAME| tr -s " " | cut -d" " -f5 2>/dev/null)
                [ "$VER" != "*" -a "$VER" != "$FVER" ] &&
  		   { echo "Could not match $VER for file $FNAME"; return 1; }
	    done
	    shift
	done
    done
    return 0
}

job_build() {
    init_job
    local REPO=$1; shift;
    local CMSDIST="CMSDIST.$REPO"
    local BASETAG=$1; local PROJ=$2; shift 2;

    exec &> $LOG_FILE.$PROJ.$REPO.chk  # Set new log file

    echo; echo "---------[$BASETAG $PROJ]----------"
    mkdir -p $BUILDS/$PROJ; cd $BUILDS/$PROJ
    acquire_lock $PROJ ||
	{ echo "Project $PROJ locked by other process. Skipping."; exit 1; }
    trap 'def_job_exit_trap; release_lock $PROJ' EXIT


    local REBUILD=1
    if [ ! -d "$CMSDIST" ]; then
	cvs -Q co -r $BASETAG -d $CMSDIST CMSDIST ||
	    { echo "Error while getting files from CVS"; exit 1; }
	REBUILD=0
    elif [ "$(cat $CMSDIST/CVS/Tag |cut -b2-)" != "$BASETAG" ]; then
	#cvs -Q diff -N -r $BASETAG $CMSDIST || REBUILD=0
	cvs -Q up -r $BASETAG $CMSDIST || 
	    { echo "Error while getting files from CVS"; exit 1; }
	REBUILD=0
    fi
    process_delta $CMSDIST $@ && REBUILD=0
    [ $REBUILD = 0 ] ||
        { echo "Nothing changed. Build not necessary"; exit 1; };


    echo "Rebuilding project $PROJ. See logfile $LOG_FILE.$PROJ.$REPO"

    exec &> $LOG_FILE.$PROJ.$REPO  # Set new log file

    # Creates a cmsBuild configuration file
    create_buildcfg $PROJ $REPO > cmsbuild.cfg
    
    # Builds it
    [ -d "tmp" -o -d "w" ] && rm -rf tmp w
    run_job $CMSBUILD --architecture=$SCRAM_ARCH --cfg=./cmsbuild.cfg --cmsdist=$CMSDIST --work-dir=w
    wait % || { echo "BUILD: project $PROJ failed to build."; exit 2; }

    update_status $REPO $PROJ ||
    	{ echo "BUILD: project $PROJ produced no new RPMs. Skipping."; exit 2; }
	
    # Creates the cmsBuild upload configuration file
    sed s/#//g cmsbuild.cfg > cmsupload.cfg

    # Now does the upload and update at once
    run_job job_upload $REPO $PROJ
    wait % || { echo "BUILD: failed to upload $PROJ to repo $REPO"; exit 2; }

    exit 0
}

# The worst case is when the packages get uploaded
# but the status information is not updated. This would be fixed by the
# next run, unless the project tags change between such executions. In this
# case, the old status info doesn't matter anyway (at least for pre-prod).
# 
# Call it only if you have already have the lock
job_upload() {
    init_job
    trap '' EXIT # there is nothing to clean here
    trap 'echo "UPLOAD: cannot TERM while uploading $PROJ"' SIGINT SIGTERM
    local REPO=$1; local PROJ=$2;

    cd $BUILDS/$PROJ
    
    # First uploads to the repository
    $CMSBUILD --architecture=$SCRAM_ARCH --cfg=./cmsupload.cfg --cmsdist=CMSDIST.$REPO --work-dir=w ||
       { echo "UPLOAD: project $PROJ failed to upload.";  exit 1; }

    exit 0 # upload succeeded
}

update_status() {
    local REPO=$1; local PROJ=$2;

    # Rpm list generated by this build
    local RPM_FILES=$(find $BUILDS/$PROJ/w/RPMS/$SCRAM_ARCH/ -name "*rpm" | tr '\n' ' ')
    [ -z "$RPM_FILES" ] &&
	return 1 # don't need to update status nor upload anything

    local RPMS=""
    for RPM in $RPM_FILES; do 
	RPM=${RPM%-1-1.$SCRAM_ARCH.rpm} # strip stuff from the end
	RPM=${RPM##*/} # strip the dir path from the beginning
	RPMS+=" $RPM"
    done

    # Creates a new tag
    local TAG="builder_$(date +%Y-%m-%d_%H-%M-%S)_${PROJ}"
    cvs tag -F $TAG CMSDIST.$REPO

    # Prepares the status information
    local DATE=$(date +"%Y-%m-%d %H:%M:%S %z %a")
    local DIFF="-"

    # Updates the status pages
    for RPM in $RPMS; do
	local PKG=$(echo $RPM|cut -d"+" -f2)
	local ENTRY="| $PKG  | $RPM  | $DATE  | $DIFF  | $TAG  |"
	echo "$ENTRY" >> $WEB/$PKG.$REPO.history
	echo -n "$ENTRY" > $WEB/$PKG.$REPO
    done

    return 0
}

create_buildcfg() {
    local PROJ=$1; local REPO=${2:-comp.pre}; # REPO=comp or REPO=comp.pre
    cat << EOF_CFG
[globals]
assumeYes: True
onlyOnce: True
testTag: False
trace: False
tag: cmp
repository: $REPO
[bootstrap]
priority: -30
doNotBootstrap: True
repositoryDir: $REPO
[build $1]
compilingProcesses: 10
workersPoolSize: 5
priority: -20
#[upload $1]
#priority: 100
#syncBack: True
EOF_CFG
}

acquire_lock() {
    local PROJ=$1

    # Creates the working area (this works as a lock -- will avoid
    # runnning if there is evidence of another running instance)
    echo "Trying to acquire $BUILDS/$PROJ/lock ..."
    mkdir "$BUILDS/$PROJ/lock" &> /dev/null &&
       { echo "Got $BUILDS/$PROJ/lock"; return 0; }

    # Now tries to recover it
    local LAST_CHANGE=$(stat -c %Z $BUILDS/$PROJ/lock)
    # Here we should remove the lock and clean stuff in case
    # the lock's age is bigger than the watchdog timeout
    if [ $(($(date +%s) - $TIMEOUT - 5)) -gt $LAST_CHANGE ]; then
        # There is a small chance, though, that another process 
        # has just released and created it again... **Should fix it**
        # This would happen if two concurrent processes try recover it
        # at the same time.
	release_lock $PROJ
	mkdir "$BUILDS/$PROJ/lock" &> /dev/null &&
	   { echo "Got $BUILDS/$PROJ/lock"; return 0; }
    fi

    echo "Could not get $BUILDS/$PROJ/lock"
    return 1 # could not get the lock
}

release_lock() {
    local PROJ=$1
    echo "Cleanning $BUILDS/$PROJ/lock"
    [ -n "$BUILDS" -a -n "$PROJ" ] &&
       rmdir "$BUILDS/$PROJ/lock"
}
