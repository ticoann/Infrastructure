def_job_exit_trap() { wait; }

def_job_term_trap() {
    echo "Sending TERM to ${MYCHLD}..."
    kill -SIGTERM $MYCHLD &>/dev/null

    # Explicitly exits, thus avoiding continuing from where the trap occured.
    # Will not call the EXIT trap if it was there when TERM was received. 
    exit 1
}

init_job() {
    MYCHLD=" " # this maintains a list of child processes PIDs
    trap 'def_job_exit_trap' EXIT
    trap 'def_job_term_trap' SIGTERM SIGINT
}

run_job() {
    $@ &  # $@ is whatever cames as argument
    MYCHLD+=" $!" # add the child pid to the children list
}

job_process_file() {
    init_job
    local REPO=${1:-comp.pre}
    local FILE="${REPO/%comp/comp.}releases"

    # Gets/updates the latest CMSDIST
    cd $BUILDER_ROOT/var
    cvs co -d CMSDIST.HEAD CMSDIST/$FILE ||
        { echo "Could not fetch CMSDIST/$FILE. Skipping it."; exit 1; }

    # Now parses the CMSDIST.HEAD/$FILE
    # Problems with a read in a while loop forced me to this parsing solution
    local LINES=$(cat $BUILDER_ROOT/var/CMSDIST.HEAD/$FILE|tr -s '\t \n' '## ')
    for LINE in $LINES; do
	[ "${LINE:0:1}" = "#" ] && continue # skip commented out lines
	if ! [[ $LINE =~ [^a-zA-Z0-9_\-\#] ]]; then
	    # Means that the line contains only valid characters,
	    # so we can use it safely.
            echo "$FILE: ${LINE//#/ }"
	    local DEVTAG=$(echo $LINE | cut -s -d"#" -f1)
	    local PROJ=$(echo $LINE | cut -s -d"#" -f2) 
	    local PROJ_LIST=$(echo $LINE | cut -s -d"#" -f2-|tr -s '#' ' ')

	    if [ -z "$PROJ" -o -z "$DEVTAG" ]; then
		echo "   Empty project name or dev tag. Skipping..."
	    #elif [[ ! $ACCEPTED_PROJS =~ "^$PROJ | $PROJ$| $PROJ |^$PROJ$" ]]; then
	    #    echo "PROCESS $REPO: $PROJ not in the accepted projects list"
	    else
		local LASTENTRY=$(cat $CACHE/$PROJ.$REPO.buildentry 2>/dev/null)
		if [ "$LASTENTRY" = "$DEVTAG $PROJ_LIST" ]; then
		    echo "   Build entry already processed. Skipping..."
		else
		    run_job job_build $DEVTAG $REPO $PROJ_LIST
		    # wait % # the job_build result doesn't matter
		    echo "   Build started. See $LOG_FILE.$PROJ.$REPO"
		fi
	    fi
	fi
    done

    exit 0 # job succeeded
}

job_build() {
    init_job
    local DEVTAG=$1; local REPO=$2; shift 2;
    local PROJ_LIST="$@"; 
    local PROJ=$(echo "$PROJ_LIST"|cut -d" " -f1); 

    exec &> $LOG_FILE.$PROJ.$REPO  # Set new log file

    acquire_lock $PROJ ||
       { echo "BUILD: project $PROJ locked by other process. Skipping."; exit 1; }

    trap 'def_job_exit_trap; release_lock $PROJ' EXIT

    cd $BUILDS/$PROJ

    # Now creates/fetches the CMSDIST
    if [ "$REPO" = "comp" ]; then
	cvs co -r $DEVTAG CMSDIST || 
	{ echo "BUILD: failed to get cvs CMSDIST for $PROJ"; exit 2; }
    else # REPO is comp.pre
        # Creates a CMSDIST based on the developer tag
	run_job $TAGBUILDER $DEVTAG $PROJ_LIST
	wait % || { echo "BUILD: could not prepare a tag for project $PROJ" ; exit 2; }
    fi

    # Creates a cmsBuild configuration file
    create_buildcfg $PROJ $REPO > cmsbuild.cfg
    
    # Builds it
    run_job $CMSBUILD --architecture=$SCRAM_ARCH --cfg=./cmsbuild.cfg --work-dir=w
    wait % || { echo "BUILD: project $PROJ failed to build."; exit 3; }
    
    update_status $REPO $PROJ ||
       { echo "BUILD: project $PROJ produced no new RPMs. Skipping."; exit 3; }

    # Creates the cmsBuild upload configuration file
    sed s/#//g cmsbuild.cfg > cmsupload.cfg

    # Now does the upload and update at once
    run_job job_upload $REPO $PROJ
    wait % || { echo "BUILD: failed to upload $PROJ to repo $REPO"; exit 4; }

    echo "$DEVTAG $PROJ_LIST" > $CACHE/$PROJ.$REPO.buildentry
    exit 0; # Build successfull
}

# The worst case is when the packages get uploaded
# but the status information is not updated. This would be fixed by the
# next run, unless the project tags change between such executions. In this
# case, the old status info doesn't matter anyway (at least for pre-prod).
# 
# Call it only if you have already have the lock
job_upload() {
    init_job
    trap '' EXIT # there is nothing to clean here
    trap 'echo "UPLOAD: cannot TERM while uploading $PROJ"' SIGINT SIGTERM
    local REPO=$1; local PROJ=$2;

    cd $BUILDS/$PROJ
    
    # First uploads to the repository
    $CMSBUILD --architecture=$SCRAM_ARCH --cfg=./cmsupload.cfg --work-dir=w ||
       { echo "UPLOAD: project $PROJ failed to upload.";  exit 1; }

    exit 0 # upload succeeded
}

update_status() {
    local REPO=$1; local PROJ=$2;

    # Rpm list generated by this build
    local RPM_FILES=$(find $BUILDS/$PROJ/w/RPMS/$SCRAM_ARCH/ -name "*rpm" | tr '\n' ' ')
    [ -z "$RPM_FILES" ] &&
	return 1 # don't need to update status nor upload anything

    local RPMS=""
    for RPM in $RPM_FILES; do 
	RPM=${RPM%-1-1.$SCRAM_ARCH.rpm} # strip stuff from the end
	RPM=${RPM##*/} # strip the dir path from the beginning
	RPMS+=" $RPM"
    done

    # Creates a new tag
    local TAG="builder_$(date +%Y-%m-%d_%H-%M-%S)_${PROJ}"
    cvs tag -F $TAG CMSDIST

    # Prepares the status information
    local DATE=$(date)
    local DIFF="_not yet available_"

    # Updates the status pages
    for RPM in $RPMS; do
	local PKG=$(echo $RPM|cut -d"+" -f2)
	local ENTRY="|  $PKG  |  $RPM  |  $DATE  |  $DIFF  |  $TAG  |"
	echo "$ENTRY" >> $WEB/$PKG.$REPO.history
	echo -n "$ENTRY" > $WEB/$PKG.$REPO
    done

    return 0
}

create_buildcfg() {
    local PROJ=$1; local REPO=${2:-comp.pre}; # REPO=comp or REPO=comp.pre
    cat << EOF_CFG
[globals]
assumeYes: True
onlyOnce: True
testTag: False
trace: True
tag: cmp
repository: $REPO
[bootstrap]
priority: -30
doNotBootstrap: True
repositoryDir: $REPO
[build $1]
compilingProcesses: 6
workersPoolSize: 2
priority: -20
#[upload $1]
#priority: 100
#syncBack: True
EOF_CFG
}

acquire_lock() {
    local PROJ=$1

    # Creates the working area (this works as a lock -- will avoid
    # runnning if there is evidence of another running instance)
    echo "Trying to acquire lock $BUILDS/$PROJ ..."
    mkdir "$BUILDS/$PROJ" &> /dev/null &&
       { echo "Got the lock $BUILDS/$PROJ"; return 0; }

    # Now tries to recover it
    local LAST_CHANGE=$(stat -c %Z $BUILDS/$PROJ)
    # Here we should remove the lock and clean stuff in case
    # the lock's age is bigger than the watchdog timeout
    if [ $(($(date +%s) - $TIMEOUT - 5)) -gt $LAST_CHANGE ]; then
        # There is a small chance, though, that another process 
        # has just released and created it again... **Should fix it**
        # This would happen if two concurrent processes try recover it
        # at the same time.
	release_lock $PROJ
	mkdir "$BUILDS/$PROJ" &> /dev/null &&
	   { echo "Got the lock $BUILDS/$PROJ"; return 0; }
    fi

    echo "Could not get the lock $BUILDS/$PROJ"
    return 1 # could not get the lock
}

release_lock() {
    local PROJ=$1
    echo "Cleanning $BUILDS/$PROJ"
    [ -n "$BUILDS" -a -n "$PROJ" ] &&
       rm -rf "$BUILDS/$PROJ"
}
