#!/usr/bin/python

# Script to report CMSWEB audit info in logwatch reports.
#
# Queries ausearch tool using time interval for 'yesterday', and produces a
# summary result of the findings to the standard output where logwatch will
# grab it and include in daily e-mail reports.

import os, sys, subprocess, re
from datetime import date, timedelta

# Regular expression for system libraries which are common to be missing,
# and which we don't care about reporting. See filter_path() for use.
rxsyslib = re.compile(r".*/(?:tls/(?:x86_64/)?)?lib"
                      "(c|com_err|dl|gssapi_krb5|k5crypto|keyutils|krb5|"
                      "krb5support|m|nss_files|pthread|resolv|rt|"
                      "selinux|sepol)\.so\.\d+$")

# Parse one input block. Turns the block into a tuple (type, dict) where the
# dictionary describes all the relevant information for one audit entry.
def parse(block):
  lines = [line.rstrip() for line in block.split('\n')]
  type = None
  info = {}
  paths = []

  for line in lines:
    if line.startswith("type=PATH "):
      line = re.sub(r"^type=PATH msg=\S+ \S+ : ", "", line)
      m = re.match(r"^item=(\d+) name=", line)
      id = m.group(1)
      line = line[m.end():]
      m = re.search(r" inode=(\d+) dev=(\d+:\d+) ", line)
      if m: p = (int(id), line[0:m.start()], m.group(1), m.group(2))
      else: p = (int(id), line, None, None)
      paths.append(p)
    elif line.startswith("type=CWD "):
      info['cwd'] = re.sub(r"^type=CWD msg=\S+ \S+ :\s+cwd=", "", line)
    elif line.startswith("type=EXECVE "):
      line = re.sub(r"^type=EXECVE msg=\S+ \S+ : argc=\S+", "", line)
      info['execve-args'] = re.split(r" a(?:\d+)=", line)[1:]
    elif line.startswith("type=SYSCALL "):
      line = re.sub(r"^type=SYSCALL msg=\S+ \S+ :", "", line)
      info.update(re.findall(r" ([a-z0-9]+)=(-?\d+\([^)]+\)|\S+)", line))
      type = 'syscall'
    # elif line.startswith("type=CONFIG_CHANGE "): pass
    # elif line.startswith("type=CRED_ACQ "): pass
    # elif line.startswith("type=CRED_DISP "): pass
    # elif line.startswith("type=LOGIN "): pass
    # elif line.startswith("type=USER_ACCT "): pass
    # elif line.startswith("type=USER_AUTH "): pass
    # elif line.startswith("type=USER_CMD "): pass
    # elif line.startswith("type=USER_END "): pass
    # elif line.startswith("type=USER_START "): pass

  if 'cwd' in info:
    paths = ((i, (p == "(null)" and "[%s@%s]" % (inode,dev)) \
              or os.path.join(info['cwd'], p))
             for i, p, inode, dev in paths)
  if paths:
    info['paths'] = [p for i, p in sorted(paths)]

  return (type, info)

# Make an execve() command argv into a string. Mostly formats it as would
# be seen in shell scripts.
def command(info):
  if 'execve-args' not in info:
    return "(no command recorded!)"

  args = info['execve-args']
  for i in xrange(0, len(args)):
    if not re.match(r"^[-_.,:/@+A-Za-z0-9]+$", args[i]):
      args[i] = repr(args[i])
  return " ".join(args)

# Make a path list for a syscall into a string. Simply concatenates all the
# paths with semicolons, which is pretty reasonable for most syscalls.
def pathlist(info):
  if 'paths' not in info:
    return "(no paths recorded!)"
  return "; ".join(info['paths'])

# Pick one path out of syscall path parameter list. Use this when a syscall
# may have additional paths, e.g. unlink() may report directory and file.
# Picks file N if it exists, otherwise the last path in the list.
def onepath(info, n):
  if 'paths' not in info:
    return "(no paths recorded!)"
  if len(info['paths']) > n:
    return info['paths'][n]
  else:
    return info['paths'][-1]

# Format an executable name nicely. Produces maximum 30 character wide name,
# stripping characters off the middle if the name is longer than that.
def exename(name):
  if len(name) > 30:
    return name[0:10] + ".." + name[-18:]
  else:
    return name

# Return integer error code and error string for a syscall which failed.
def error(info):
  m = re.match(r"^(-?\d+)\((.*)\)$", info['exit'])
  return (-int(m.group(1)), m.group(2))

# Increment count of found keys in some dictionary.
def tick(dict, key):
  if key not in dict:
    dict[key] = 1
  else:
    dict[key] += 1

# Sum the values in DICT whose keys are tuples starting with KEYPFX.
def pfxsum(dict, keypfx):
  return sum([v for k, v in dict.iteritems() if k[0:len(keypfx)] == keypfx])

# Count the keys in DICT which are tuples starting with KEYPFX.
def pfxcount(dict, keypfx):
  return len([k for k in dict.keys() if k[0:len(keypfx)] == keypfx])

# Decide if we should report this syscall by looking at which paths it
# accesses. Skip commonly used shared libraries which are ok not to be
# found in $LD_LIBRARY_PATH search, and files opened in read-only mode
# and which pretty much every process will access sooner or later.
def filter_path(info):
  if (info['syscall'] == 'open'
      and info['exit'] in ('0', '-13(Permission denied)')
      and info.get('paths', None)
      and rxsyslib.match(info['paths'][0])):
    return True

  if (info['syscall'] == 'open'
      and info['success'] == 'yes'
      and info['a1'] == '0'
      and info.get('paths', None)
      and info['paths'][0] in ('/etc/sysconfig/i18n',
                               '/etc/passwd',
                               '/etc/shadow',
                               '/etc/pam.d/crond',
                               '/etc/pam.d/other',
                               '/etc/pam.d/system-auth')):
    return True

  return False

# Summarise the audit info results. Consumes parse() output.
def summarise(data):
  path_failure = {} # (error, user, path, syscall, exe)
  path_success = {} # (user, path, syscall, exe)

  exec_failure = {} # (error, user, exe, command)
  exec_success = {} # (user, exe, command)

  exit_failure = {} # (exit-code, user, exe)
  exit_success = {} # (user, exe)

  call_failure = {} # (error, user, exe, syscall)
  call_success = {} # (user, exe, syscall)

  # Decode the audit info object and tick various events.
  for type, info in data:
    if type == None:
      pass
    elif type == 'syscall':
      if filter_path(info):
        pass
      elif info['syscall'] == 'execve':
        if info['success'] == 'yes':
          tick(exec_success, (info['uid'], info['exe'], command(info)))
        else:
          tick(exec_failure, (error(info), info['uid'], info['exe'], command(info)))
      elif info['syscall'] in ('unlink', 'rmdir'):
        if info['success'] == 'yes':
          tick(path_success, (info['uid'], onepath(info, 1), info['syscall'], info['exe']))
        else:
          tick(path_failure, (error(info), info['uid'], onepath(info, 1), info['syscall'], info['exe']))
      elif info['syscall'] in ('open', 'rename', 'mkdir', 'chmod', 'chown'):
        if info['success'] == 'yes':
          tick(path_success, (info['uid'], pathlist(info), info['syscall'], info['exe']))
        else:
          tick(path_failure, (error(info), info['uid'], pathlist(info), info['syscall'], info['exe']))
      elif info['syscall'] == 'exit':
        if info['a0'] == '0':
          tick(exit_success, (info['uid'], info['exe']))
        else:
          tick(exit_failure, (int(info['a0']), info['uid'], info['exe']))
      else:
        if info['success'] == 'yes':
          tick(call_success, (info['uid'], info['syscall'], info['exe']))
        else:
          tick(call_failure, (error(info), info['uid'], info['syscall'], info['exe']))
        if 'paths' in info:
          print "ERROR: syscall with paths not understood", info
    else:
      print "ERROR: audit entry not understood", info

  # Report the different events, first failures then successes.
  pad = ""
  if exec_failure:
    print "%sFailures to execute commands: %d unique, %d total" % \
      (pad, len(exec_failure), sum([v for v in exec_failure.values()]))
    prev_error = None
    prev_user  = None
    for key in sorted(exec_failure.keys()):
      err, user, exe, cmd = key
      if prev_error != err:
        print "\n  %s (%d): %d unique, %d total" % \
          (err[1], err[0],
           pfxcount(exec_failure, (err,)),
           pfxsum(exec_failure, (err,)))
        prev_error = err
        prev_user = None
      if prev_user != user:
        print "\n    %s: %d unique, %d total" % \
          (user,
           pfxcount(exec_failure, (err, user)),
           pfxsum(exec_failure, (err, user)))
        prev_user = user
      print "      %-4d %-30s %s" % (exec_failure[key], exename(exe), cmd)
    pad = "\n\n"

  if path_failure:
    print "%sFailures to access files: %d unique, %d total" % \
      (pad, len(path_failure), sum([v for v in path_failure.values()]))
    prev_error = None
    prev_user  = None
    for key in sorted(path_failure.keys()):
      err, user, path, syscall, exe = key
      if prev_error != err:
        print "\n  %s (%d): %d unique, %d total" % \
          (err[1], err[0],
           pfxcount(path_failure, (err,)),
           pfxsum(path_failure, (err,)))
        prev_error = err
        prev_user = None
      if prev_user != user:
        print "\n    %s: %d unique, %d total" % \
          (user,
           pfxcount(path_failure, (err, user)),
           pfxsum(path_failure, (err, user)))
        prev_user = user
      print "      %-4d %s [%s, %s]" % (path_failure[key], path, syscall, exe)
    pad = "\n\n"

  if call_failure:
    print "%sFailures to execute system calls: %d unique, %d total" % \
      (pad, len(call_failure), sum([v for v in call_failure.values()]))
    prev_error = None
    prev_user  = None
    for key in sorted(call_failure.keys()):
      err, user, call, exe = key
      if prev_error != err:
        print "\n  %s (%d): %d unique, %d total" % \
          (err[1], err[0],
           pfxcount(call_failure, (err,)),
           pfxsum(call_failure, (err,)))
        prev_error = err
        prev_user = None
      if prev_user != user:
        print "\n    %s: %d unique, %d total" % \
          (user,
           pfxcount(call_failure, (err, user)),
           pfxsum(call_failure, (err, user)))
        prev_user = user
      print "      %-4d %s [%s]" % (exec_failure[key], call, exe)
    pad = "\n\n"

  if exit_failure:
    print "%sFailures from applications: %d unique, %d total" % \
      (pad, len(exit_failure), sum([v for v in exit_failure.values()]))
    prev_error = None
    prev_user  = None
    for key in sorted(exit_failure.keys()):
      err, user, exe = key
      if prev_error != err:
        print "\n  %d: %d unique, %d total" % \
          (err,
           pfxcount(exit_failure, (err,)),
           pfxsum(exit_failure, (err,)))
        prev_error = err
        prev_user = None
      if prev_user != user:
        print "\n    %s: %d unique, %d total" % \
          (user,
           pfxcount(exit_failure, (err, user)),
           pfxsum(exit_failure, (err, user)))
        prev_user = user
      print "      %-4d %s" % (exec_failure[key], exe)
    pad = "\n\n"

  if exec_success:
    print "%sSuccessfully executed commands: %d unique, %d total" % \
      (pad, len(exec_success), sum([v for v in exec_success.values()]))
    prev_user = None
    for key in sorted(exec_success.keys()):
      user, exe, cmd = key
      if prev_user != user:
        print "\n  %s: %d unique, %d total" % \
          (user,
           pfxcount(exec_success, (user,)),
           pfxsum(exec_success, (user,)))
        prev_user = user
      print "    %-4d %-30s %s" % (exec_success[key], exename(exe), cmd)
    pad = "\n\n"

  if path_success:
    print "%sSuccessfully accessed paths: %d unique, %d total" % \
      (pad, len(path_success), sum([v for v in exec_success.values()]))
    prev_user = None
    for key in sorted(path_success.keys()):
      user, path, syscall, exe = key
      if prev_user != user:
        print "\n  %s: %d unique, %d total" % \
          (user,
           pfxcount(path_success, (user,)),
           pfxsum(path_success, (user,)))
        prev_user = user
      print "    %-4d %s [%s, %s]" % (path_success[key], path, syscall, exe)
    pad = "\n\n"

  if call_success:
    print "%sSuccessfully executed system calls: %d unique, %d total" % \
      (pad, len(call_success), sum([v for v in call_success.values()]))
    prev_user = None
    for key in sorted(call_success.keys()):
      user, call, exe = key
      if prev_user != user:
        print "\n  %s: %d unique, %d total" % \
          (user,
           pfxcount(call_success, (user,)),
           pfxsum(call_success, (user,)))
        prev_user = user
      print "    %-4d %s [%s]" % (call_success[key], call, exe)
    pad = "\n\n"

  if exit_success:
    print "%sSuccessful application exits: %d unique, %d total" % \
      (pad, len(exit_success), sum([v for v in exit_success.values()]))
    prev_user = None
    for key in sorted(exit_success.keys()):
      user, exe = key
      if prev_user != user:
        print "\n  %s: %d unique, %d total" % \
          (user,
           pfxcount(exit_success, (user,)),
           pfxsum(exit_success, (user,)))
        prev_user = user
      print "    %-4d %s" % (exit_success[key], exe)
    pad = "\n\n"

# Main program. Read ausearch output and digest it, generate summary.
if __name__ == '__main__':
  cmd = ['/sbin/ausearch', '--input-logs', '-i',
         '-ts', 'yesterday', '00:00:00',
         '-te', 'yesterday', '23:59:59']
  try:
    (output, err) = subprocess.Popen(cmd, stdout=subprocess.PIPE).communicate()
    if err:
      print "Errors occured while trying to read log files."
      for error in err:
        print "Error: %s" % error
        print "-----------------------------------------------\n"
        sys.exit(-2)
  except Exception, e:
    print "ERROR: problem while reading audit logs. Please check if auditd installed and running."
    sys.exit(-1)

  summarise([parse(block) for block in output.split('----') if block])
  sys.exit(0)
