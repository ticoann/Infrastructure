#!/usr/bin/python

# Script to report CMSWEB audit info in logwatch reports.
#
# Queries ausearch tool using time interval for 'yesterday', and produces a
# summary result of the findings to the standard output where logwatch will
# grab it and include in daily e-mail reports.

import os, sys, subprocess, re
from datetime import date, timedelta

# Regular expression for system libraries which are common to be missing,
# and which we don't care about reporting. See filter_path() for use.
rxsyslib = re.compile(r".*/(?:tls/(?:x86_64/)?)?lib"
                      "(c|com_err|dl|gssapi_krb5|k5crypto|keyutils|krb5|"
                      "krb5support|m|nss_files|pthread|resolv|rt|"
                      "selinux|sepol)\.so\.\d+$")

# Regexp for compacting mail queue file names.
rxmqueue = re.compile(r"^(/var/spool/(?:client)?mqueue/\./)([0-9A-Za-z]+)$")

# Regexps for compacting apache disk cache file names.
rxphedex = re.compile(r"^/data/srv[-a-z]*/state/phedex/cache/phedex-datasvc/")
rxapache = re.compile(r"^/data/srv[-a-z]*/[a-z0-9]+/sw[.a-z]*/[_a-z0-9]+/"
		      r"external/apache2/[-.a-z0-9]+/bin/httpd$")
rxapcachedir = re.compile(r"^(?:/[A-Za-z0-9_@]+){0,2}$")
rxapcachedirv = re.compile(r"^(?:/[A-Za-z0-9_@]+){3}\.header\.vary"
                           r"(?:/[A-Za-z0-9_@]+){0,2}$")
rxapcachehdr = re.compile(r"^(?:/[A-Za-z0-9_@]+){3}\.header$")
rxapcachehdrv = re.compile(r"^(?:/[A-Za-z0-9_@]+){3}\.header\.vary"
                           r"(?:/[A-Za-z0-9_@]+){3}\.header$")
rxapcachehdrvd = re.compile(r"^(?:/[A-Za-z0-9_@]+){3}\.header\.vary"
                            r"(?:/[A-Za-z0-9_@]+){3}\.data$")

# Regexps for compacting DQM GUI commands and file names.
rxdqm = ((re.compile(r"^(basename) (/data/srv/state/dqmgui/[a-z]+/data/OnlineData"
                     r"/(?:merged|original))/\d{5}xxxx$"),
          [r"\1", r"\2/NNNNNxxxx"]),

         (re.compile(r"^(basename) (dqm/online/data/browse/(?:Original|Merged))"
                     r"/\d{5}xxxx/\d{7}xx/DQM[-_A-Za-z0-9]+\.root$"),
          [r"\1", r"\2/NNNNNxxxx/NNNNNNNxx/DQM.root"]),

         (re.compile(r"^(stat) \d{5}xxxx(?:/\d{7}xx)?/"
                     r"(?:index\.html|DQM[-_A-Za-z0-9]+\.root) (-c) (%Y)$"),
          [r"\1", r"NNNNNxxxx/NNNNNNNxx/DQM.root", r"\2", r"\3"]),

         (re.compile(r"^(chmod) (o\+rx) (/data/srv/state/dqmgui/[a-z]+/data/OnlineData)"
                     r"(?:[/A-Za-z0-9]*)"),
          [r"\1", r"\2", r"\3/X"]),

         (re.compile(r"^(date) (-d) '[A-Za-z0-9,:\s]+\\r' \+%s$"),
          [r"\1", r"\2", r"'(DATE)' +%s"]),

         (re.compile(r"^(curl) (-A) ([A-Za-z0-9./]+) (-s) (-R) (-o)"
                     r" (?:\d+x+(?:/\d+x+)?/(?:index\.html|DQM[-_A-Za-z0-9]+\.root))"
                     r" (--create-dirs) (--capath) (/etc/grid-security/certificates/?)"
                     r" (--key) (/data/srv/state/dqmgui/proxy/proxy\.cert)"
                     r" (--cert) (/data/srv/state/dqmgui/proxy/proxy\.cert)"
                     r" (https://cmsweb\.cern\.ch/dqm/online/data/browse)/"
                     r"(?:Merged|Original)(?:/\d+x+){0,2}/(?:DQM[-_A-Za-z0-9]+\.root)?$"),
          [r"\1", r"\2", r"\3", r"\4", r"\5", r"\6", "Rx/Rx/DQM.root", r"\7", r"\8", r"\9", r"\10", r"\11", r"\12", r"\13/A/Rx/Rx/DQM.root" ]),

         (re.compile(r"^(curl) (-A) ([A-Za-z0-9./]+) (-s) (-I)"
                     r" (--capath) (/etc/grid-security/certificates/?)"
                     r" (--key) (/data/srv/state/dqmgui/proxy/proxy\.cert)"
                     r" (--cert) (/data/srv/state/dqmgui/proxy/proxy\.cert)"
                     r" (https://cmsweb\.cern\.ch/dqm/online/data/browse)/"
                     r"(?:Merged|Original)(?:/$|/\d+x+){0,2}/(?:DQM[-_A-Za-z0-9]+\.root)?$"),
          [r"\1", r"\2", r"\3", r"\4", r"\5", r"\6", r"\7", r"\8", r"\9", r"\10", r"\11", r"\12/A/Rx/Rx/DQM.root" ]),

         (re.compile(r"^(curl) (-A) ([A-Za-z0-9./]+)"
                     r" (--capath) (/etc/grid-security/certificates/?)"
                     r" (--key) (/data/srv/state/dqmgui/proxy/proxy\.cert)"
                     r" (--cert) (/data/srv/state/dqmgui/proxy/proxy\.cert)"
                     r" (https://cmsweb\.cern\.ch/dqm/online/data/browse)/"
                     r"(?:Merged|Original)(?:/$|/\d+x+){0,2}(?:/DQM[-_A-Za-z0-9]+\.root)?$"),
          [r"\1", r"\2", r"\3", r"\4", r"\5", r"\6", r"\7", r"\8", r"\9", r"\10/A/Rx/Rx/DQM.root" ]),

         (re.compile(r"^sh -c \"(exec perl -e 'alarm\(\d+\); exec qw\(root -n -l -b -q)"
                     r" (/data/srv/state/dqmgui/[a-z]+/uploads)/\d+/DQM[-_A-Za-z0-9]+\.root"
                     r" (/data/srv[-a-z]*/[a-z0-9]+/sw[.a-z]*/[_a-z0-9]+/cms/dqmgui/"
                     r"[-.a-z0-9]+/data/root/visDQMVerify[A-Za-z]+\.C\)' 2>&1 >/dev/null)\"$"),
          ["sh", "-c", r"\1 \2/NNNN/DQM.root \3"]),

         (re.compile(r"^perl -e '(alarm\(\d+\); exec qw\(root -n -l -b -q)"
                     r" (/data/srv/state/dqmgui/[a-z]+/uploads)/\d+/DQM[-_A-Za-z0-9]+\.root"
                     r" (/data/srv[-a-z]*/[a-z0-9]+/sw[.a-z]*/[_a-z0-9]+/cms/dqmgui/"
                     r"[-.a-z0-9]+/data/root/visDQMVerify[A-Za-z]+\.C\))'$"),
          ["perl", "-e", r"\1 \2/NNNN/DQM.root \3"]),

         (re.compile(r"^(root) (-n) (-l) (-b) (-q)"
                     r" (/data/srv/state/dqmgui/[a-z]+/uploads)/\d+/DQM[-_A-Za-z0-9]+\.root"
                     r" (/data/srv[-a-z]*/[a-z0-9]+/sw[.a-z]*/[_a-z0-9]+/cms/dqmgui/"
                     r"[-.a-z0-9]+/data/root/visDQMVerify[A-Za-z]+\.C)$"),
          [r"\1", r"\2", r"\3", r"\4", r"\5", r"\6/NNNN/DQM.root", r"\7"]),

         (re.compile(r"^(/data/srv[-a-z]*/[a-z0-9]+/sw[.a-z]*/[_a-z0-9]+/lcg/root/"
                     r"[-.a-z0-9]+/bin/root\.exe) (-splash) (-n) (-l) (-b) (-q)"
                     r" (/data/srv/state/dqmgui/[a-z]+/uploads)/\d+/DQM[-_A-Za-z0-9]+\.root"
                     r" (/data/srv[-a-z]*/[a-z0-9]+/sw[.a-z]*/[_a-z0-9]+/cms/dqmgui/"
                     r"[-.a-z0-9]+/data/root/visDQMVerify[A-Za-z]+\.C)$"),
          [r"\1", r"\2", r"\3", r"\4", r"\5", r"\6", r"\7/NNNN/DQM.root", r"\8"]),

         (re.compile(r"^sh -c '((?:exec )?visDQMIndex) (add)"
                     r" (/data/srv/state/dqmgui/[a-z]+/ix)"
                     r" (/data/srv/state/dqmgui/[a-z]+/data)"
                     r"(?:/[A-Za-z0-9_]+){1,4}/DQM[-_A-Za-z0-9]+\.root'$"),
          ["sh", "-c", r"\1 \2 \3 \4/A/B/C/Rx/DQM.root"]),

         (re.compile(r"^(visDQMIndex) (add) (/data/srv/state/dqmgui/[a-z]+/ix)"
                     r" (/data/srv/state/dqmgui/[a-z]+/data)"
                     r"(?:/[A-Za-z0-9_]+){1,4}/DQM[-_A-Za-z0-9]+\.root$"),
          [r"\1", r"\2", r"\3", r"\4/A/B/C/Rx/DQM.root"]),

         (re.compile(r"^sh -c '((?:exec )?zip) (-0oqj)"
                     r" (/data/srv/state/dqmgui/[a-z]+/zipped)"
                     r"(?:/[A-Za-z0-9_]+){1,3}/DQM[-_A-Za-z0-9]+\.zip"
                     r"(?: +(/data/srv/state/dqmgui/[a-z]+/data)"
                     r"(?:/[A-Za-z0-9_]+){1,4}/DQM[-_A-Za-z0-9]+\.root)+'$"),
          ["sh", "-c", r"\1 \2 \3/A/B/C/DQM.zip \4/A/B/C/Rx/DQM.root+"]),

         (re.compile(r"^(zip) (-0oqj)"
                     r" (/data/srv/state/dqmgui/[a-z]+/zipped)"
                     r"(?:/[A-Za-z0-9_]+){1,3}/DQM[-_A-Za-z0-9]+\.zip"
                     r"(?: +(/data/srv/state/dqmgui/[a-z]+/data)"
                     r"(?:/[A-Za-z0-9_]+){1,4}/DQM[-_A-Za-z0-9]+\.root)+$"),
          [r"\1", r"\2", r"\3/A/B/C/DQM.zip", r"\4/A/B/C/Rx/DQM.root+"]),

         (re.compile(r"^(nsls) (-T) (/castor/cern.ch/cms/store/dqm/data/[a-z]+)"
                     r"(?:/[A-Za-z0-9_]+){1,4}/DQM[-_A-Za-z0-9]+\.zip$"),
          [r"\1", r"\2", r"\3/A/B/C/DQM.zip"]))

# Parse one input block. Turns the block into a tuple (type, dict) where the
# dictionary describes all the relevant information for one audit entry.
def parse(block):
  lines = [line.rstrip() for line in block.split('\n')]
  type = None
  info = {}
  paths = []

  for line in lines:
    if line.startswith("type=PATH "):
      line = re.sub(r"^type=PATH msg=\S+ \S+ : ", "", line)
      m = re.match(r"^item=(\d+)\s+name=", line)
      id = m.group(1)
      line = line[m.end():]
      m = re.search(r" inode=(\d+) dev=(\d+:\d+) ", line)
      if m: p = (int(id), line[0:m.start()], m.group(1), m.group(2))
      else: p = (int(id), line, None, None)
      paths.append(p)
    elif line.startswith("type=CWD "):
      info['cwd'] = re.sub(r"^type=CWD msg=\S+ \S+ :\s+cwd=", "", line)
    elif line.startswith("type=EXECVE "):
      line = re.sub(r"^type=EXECVE msg=\S+ \S+ : argc=\S+", "", line)
      info['execve-args'] = re.split(r" a(?:\d+)=", line)[1:]
    elif line.startswith("type=SYSCALL "):
      line = re.sub(r"^type=SYSCALL msg=\S+ \S+ :", "", line)
      info.update(re.findall(r" ([a-z0-9]+)=(-?\d+\([^)]+\)|\S+)", line))
      type = 'syscall'
    # elif line.startswith("type=CONFIG_CHANGE "): pass
    # elif line.startswith("type=CRED_ACQ "): pass
    # elif line.startswith("type=CRED_DISP "): pass
    # elif line.startswith("type=LOGIN "): pass
    # elif line.startswith("type=USER_ACCT "): pass
    # elif line.startswith("type=USER_AUTH "): pass
    # elif line.startswith("type=USER_CMD "): pass
    # elif line.startswith("type=USER_END "): pass
    # elif line.startswith("type=USER_START "): pass

  cwd = info.get('cwd', '/')
  paths = [(i, (p == "(null)" and "[%s@%s]" % (inode,dev)) or os.path.join(cwd, p))
           for i, p, inode, dev in paths]
  if paths:
    info['paths'] = [p for i, p in sorted(paths)]

  return (type, info)

# Make an execve() command argv into a string. Mostly formats it as would
# be seen in shell scripts.
def command(info):
  if 'execve-args' not in info:
    return "(no command recorded!)"

  args = info['execve-args']
  for i in xrange(0, len(args)):
    if not re.match(r"^[-_.,:/@+=%A-Za-z0-9]+$", args[i]):
      args[i] = repr(args[i])
  return " ".join(args)

# Make a path list for a syscall into a string. Simply concatenates all the
# paths with semicolons, which is pretty reasonable for most syscalls.
def pathlist(info):
  if 'paths' not in info:
    return "(no paths recorded!)"
  return "; ".join(info['paths'])

# Pick one path out of syscall path parameter list. Use this when a syscall
# may have additional paths, e.g. unlink() may report directory and file.
# Picks file N if it exists, otherwise the last path in the list.
def onepath(info, n):
  if 'paths' not in info:
    return "(no paths recorded!)"
  if len(info['paths']) > n:
    return info['paths'][n]
  else:
    return info['paths'][-1]

# Format an executable name nicely. Produces maximum 30 character wide name,
# stripping characters off the middle if the name is longer than that.
def exename(name):
  if len(name) > 30:
    return name[0:10] + ".." + name[-18:]
  else:
    return name

# Return integer error code and error string for a syscall which failed.
def error(info):
  m = re.match(r"^(-?\d+)\((.*)\)$", info['exit'])
  return (-int(m.group(1)), m.group(2))

# Increment count of found keys in some dictionary.
def tick(dict, key):
  if key not in dict:
    dict[key] = 1
  else:
    dict[key] += 1

# Sum the values in DICT whose keys are tuples starting with KEYPFX.
def pfxsum(dict, keypfx):
  return sum([v for k, v in dict.iteritems() if k[0:len(keypfx)] == keypfx])

# Count the keys in DICT which are tuples starting with KEYPFX.
def pfxcount(dict, keypfx):
  return len([k for k in dict.keys() if k[0:len(keypfx)] == keypfx])

# Decide if we should report this syscall by looking at which paths it
# accesses.
#
# Skip commonly used shared libraries which are ok not to be found in
# $LD_LIBRARY_PATH search, and files opened in read-only mode and which
# pretty much every process will access sooner or later.
#
# Convert common recurring command and path structures to templates to
# avoid excessive reporting of very common occurances. Examples include
# typical errors in manipulating apache disk cache and external commands
# run by DQM GUI.
def filter_path(info):
  # Filter permission denied access to system libraries.
  # This happens when searching for TLS, arch-specific bits.
  if (info['syscall'] == 'open'
      and info['exit'] in ('0', '-13(Permission denied)')
      and info.get('paths', None)
      and rxsyslib.match(info['paths'][0])):
    return True

  # Filter successful read-only accesses to commonly used system files.
  if (info['syscall'] == 'open'
      and info['success'] == 'yes'
      and info['a1'] == '0'
      and info.get('paths', None)
      and info['paths'][0] in ('/etc/sysconfig/i18n',
                               '/etc/passwd',
                               '/etc/shadow',
                               '/etc/pam.d/crond',
                               '/etc/pam.d/other',
                               '/etc/pam.d/system-auth')):
    return True

  # Collapse sendmail temporary files.
  if (info['exe'] == '/usr/sbin/sendmail.sendmail'
      and info['syscall'] == 'unlink'
      and info.get('paths', None)):
    m = rxmqueue.match(info['paths'][0])
    if m: info['paths'][0] = m.group(1) + ("X" * len(m.group(2)))
    return False

  # Collapse common 'errors' from apache disk cache accesses.
  if rxapache.match(info['exe']) and info.get('paths', None):
    m = rxphedex.match(info['paths'][0])
    if not m: return False

    prefix = info['paths'][0][:m.end()-1]
    path = info['paths'][0][m.end()-1:]
    if info['syscall'] == 'mkdir' and info['exit'] == '-17(File exists)':
      if rxapcachedir.match(path):
        info['paths'][0] = prefix + "/a/b"
      elif rxapcachedirv.match(path):
        info['paths'][0] = prefix + "/a/b/c.header.vary/a/b"
    elif info['syscall'] == 'unlink' and info['exit'] == '-2(No such file or directory)':
      if rxapcachehdr.match(path):
        info['paths'][0] = prefix + "/a/b/c.header"
      elif rxapcachehdrv.match(path):
        info['paths'][0] = prefix + "/a/b/c.header.vary/x/y/z.header"
      elif rxapcachehdrvd.match(path):
        info['paths'][0] = prefix + "/a/b/c.header.vary/x/y/z.data"
    return False

  # Collapse file processing commands in DQM GUI.
  if info['uid'] == '_dqmgui' and info['syscall'] == 'execve' and info['success'] == 'yes':
    cmd = command(info)
    for rx, argv in rxdqm:
      m = rx.match(cmd)
      if m:
        info['execve-args'] = [m.expand(i) for i in argv]
        return False

  return False

# Summarise the audit info results. Consumes parse() output.
def summarise(data):
  path_failure = {} # (error, user, path, syscall, exe)
  path_success = {} # (user, path, syscall, exe)

  exec_failure = {} # (error, user, exe, command)
  exec_success = {} # (user, exe, command)

  exit_failure = {} # (exit-code, user, exe)
  exit_success = {} # (user, exe)

  call_failure = {} # (error, user, exe, syscall)
  call_success = {} # (user, exe, syscall)

  # Decode the audit info object and tick various events.
  for type, info in data:
    if type == None:
      pass
    elif type == 'syscall':
      if filter_path(info):
        pass
      elif info['syscall'] == 'execve':
        if info['success'] == 'yes':
          tick(exec_success, (info['uid'], info['exe'], command(info)))
        else:
          tick(exec_failure, (error(info), info['uid'], info['exe'], command(info)))
      elif info['syscall'] in ('unlink', 'rmdir'):
        if info['success'] == 'yes':
          tick(path_success, (info['uid'], onepath(info, 1), info['syscall'], info['exe']))
        else:
          tick(path_failure, (error(info), info['uid'], onepath(info, 1), info['syscall'], info['exe']))
      elif info['syscall'] in ('access', 'creat', 'open', 'openat',
                               'truncate', 'ftruncate', 'rename', 'mkdir',
                               'chmod', 'fchmod', 'fchmodat',
                               'chown', 'fchown', 'fchownat', 'lchown',
                               'link', 'symlink', 'readlink',
                               'lsetxattr', 'lgetxattr', 'getxattr', 'fgetxattr'):
        if info['success'] == 'yes':
          tick(path_success, (info['uid'], pathlist(info), info['syscall'], info['exe']))
        else:
          tick(path_failure, (error(info), info['uid'], pathlist(info), info['syscall'], info['exe']))
      elif info['syscall'] == 'exit':
        if info['a0'] == '0':
          tick(exit_success, (info['uid'], info['exe']))
        else:
          tick(exit_failure, (int(info['a0']), info['uid'], info['exe']))
      else:
        if info['success'] == 'yes':
          tick(call_success, (info['uid'], info['syscall'], info['exe']))
        else:
          tick(call_failure, (error(info), info['uid'], info['syscall'], info['exe']))
        if 'paths' in info:
          print "ERROR: syscall with paths not understood", info
    else:
      print "ERROR: audit entry not understood", info

  # Report the different events, first failures then successes.
  pad = ""
  if exec_failure:
    print "%sFailures to execute commands: %d unique, %d total" % \
      (pad, len(exec_failure), sum([v for v in exec_failure.values()]))
    prev_error = None
    prev_user  = None
    for key in sorted(exec_failure.keys()):
      err, user, exe, cmd = key
      if prev_error != err:
        print "\n  %s (%d): %d unique, %d total" % \
          (err[1], err[0],
           pfxcount(exec_failure, (err,)),
           pfxsum(exec_failure, (err,)))
        prev_error = err
        prev_user = None
      if prev_user != user:
        print "\n    %s: %d unique, %d total" % \
          (user,
           pfxcount(exec_failure, (err, user)),
           pfxsum(exec_failure, (err, user)))
        prev_user = user
      print "      %-6d %-30s %s" % (exec_failure[key], exename(exe), cmd)
    pad = "\n\n"

  if path_failure:
    print "%sFailures to access files: %d unique, %d total" % \
      (pad, len(path_failure), sum([v for v in path_failure.values()]))
    prev_error = None
    prev_user  = None
    for key in sorted(path_failure.keys()):
      err, user, path, syscall, exe = key
      if prev_error != err:
        print "\n  %s (%d): %d unique, %d total" % \
          (err[1], err[0],
           pfxcount(path_failure, (err,)),
           pfxsum(path_failure, (err,)))
        prev_error = err
        prev_user = None
      if prev_user != user:
        print "\n    %s: %d unique, %d total" % \
          (user,
           pfxcount(path_failure, (err, user)),
           pfxsum(path_failure, (err, user)))
        prev_user = user
      print "      %-6d %s [%s, %s]" % (path_failure[key], path, syscall, exe)
    pad = "\n\n"

  if call_failure:
    print "%sFailures to execute system calls: %d unique, %d total" % \
      (pad, len(call_failure), sum([v for v in call_failure.values()]))
    prev_error = None
    prev_user  = None
    for key in sorted(call_failure.keys()):
      err, user, call, exe = key
      if prev_error != err:
        print "\n  %s (%d): %d unique, %d total" % \
          (err[1], err[0],
           pfxcount(call_failure, (err,)),
           pfxsum(call_failure, (err,)))
        prev_error = err
        prev_user = None
      if prev_user != user:
        print "\n    %s: %d unique, %d total" % \
          (user,
           pfxcount(call_failure, (err, user)),
           pfxsum(call_failure, (err, user)))
        prev_user = user
      print "      %-6d %s [%s]" % (call_failure[key], call, exe)
    pad = "\n\n"

  if exit_failure:
    print "%sFailures from applications: %d unique, %d total" % \
      (pad, len(exit_failure), sum([v for v in exit_failure.values()]))
    prev_error = None
    prev_user  = None
    for key in sorted(exit_failure.keys()):
      err, user, exe = key
      if prev_error != err:
        print "\n  %d: %d unique, %d total" % \
          (err,
           pfxcount(exit_failure, (err,)),
           pfxsum(exit_failure, (err,)))
        prev_error = err
        prev_user = None
      if prev_user != user:
        print "\n    %s: %d unique, %d total" % \
          (user,
           pfxcount(exit_failure, (err, user)),
           pfxsum(exit_failure, (err, user)))
        prev_user = user
      print "      %-6d %s" % (exec_failure[key], exe)
    pad = "\n\n"

  if exec_success:
    print "%sSuccessfully executed commands: %d unique, %d total" % \
      (pad, len(exec_success), sum([v for v in exec_success.values()]))
    prev_user = None
    for key in sorted(exec_success.keys()):
      user, exe, cmd = key
      if prev_user != user:
        print "\n  %s: %d unique, %d total" % \
          (user,
           pfxcount(exec_success, (user,)),
           pfxsum(exec_success, (user,)))
        prev_user = user
      print "    %-6d %-30s %s" % (exec_success[key], exename(exe), cmd)
    pad = "\n\n"

  if path_success:
    print "%sSuccessfully accessed paths: %d unique, %d total" % \
      (pad, len(path_success), sum([v for v in exec_success.values()]))
    prev_user = None
    for key in sorted(path_success.keys()):
      user, path, syscall, exe = key
      if prev_user != user:
        print "\n  %s: %d unique, %d total" % \
          (user,
           pfxcount(path_success, (user,)),
           pfxsum(path_success, (user,)))
        prev_user = user
      print "    %-6d %s [%s, %s]" % (path_success[key], path, syscall, exe)
    pad = "\n\n"

  if call_success:
    print "%sSuccessfully executed system calls: %d unique, %d total" % \
      (pad, len(call_success), sum([v for v in call_success.values()]))
    prev_user = None
    for key in sorted(call_success.keys()):
      user, call, exe = key
      if prev_user != user:
        print "\n  %s: %d unique, %d total" % \
          (user,
           pfxcount(call_success, (user,)),
           pfxsum(call_success, (user,)))
        prev_user = user
      print "    %-6d %s [%s]" % (call_success[key], call, exe)
    pad = "\n\n"

  if exit_success:
    print "%sSuccessful application exits: %d unique, %d total" % \
      (pad, len(exit_success), sum([v for v in exit_success.values()]))
    prev_user = None
    for key in sorted(exit_success.keys()):
      user, exe = key
      if prev_user != user:
        print "\n  %s: %d unique, %d total" % \
          (user,
           pfxcount(exit_success, (user,)),
           pfxsum(exit_success, (user,)))
        prev_user = user
      print "    %-6d %s" % (exit_success[key], exe)
    pad = "\n\n"

# Main program. Read ausearch output and digest it, generate summary.
if __name__ == '__main__':
  cmd = ['/sbin/ausearch', '--input-logs', '-i',
         '-ts', 'yesterday', '00:00:00',
         '-te', 'yesterday', '23:59:59']
  try:
    (output, err) = subprocess.Popen(cmd, stdout=subprocess.PIPE).communicate()
    if err:
      print "Errors occured while trying to read log files."
      for error in err:
        print "Error: %s" % error
        print "-----------------------------------------------\n"
        sys.exit(-2)
  except Exception, e:
    print "ERROR: problem while reading audit logs. Please check if auditd installed and running."
    sys.exit(-1)

  summarise([parse(block) for block in output.split('----') if block])
  sys.exit(0)
